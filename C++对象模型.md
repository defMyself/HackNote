# C++对象模型

## 一. 对象模型基础

C++在C的基础上引入了面向对象的程序设计思想，类的封装、继承、多态使得C++功能更加强大。C++的类包含数据成员和成员函数：

**数据成员**：静态数据成员、非静态数据成员

**成员函数**：非静态成员函数、静态函数、虚函数

C++对象模型研究C++类的数据成员和成员函数在内存中如何布局的问题。

假设有个C++类定义如下：

```cpp
class Base
{
public:
    int member;
    static int smember;
    
    void func();
    static void sfunc();
    virtual void vfunc();
}
```

* **简单对象模型**

   		在简单对象模型中，类的每个实例化对象在内存中都会申请一块连续内存，在这块内存上保存着指向成员变量和函数的指针。这样做的好处是，每个对象的内存大小是固定的，不管是数据成员还是成员函数，都值对应一个指针，在访问时可以很快计算出指针偏移量。这样做的弊端也明显，当访问对象的数据成员时，需要先找到数据成员的指针，然后通过这个指针获取到真实的数据，多了一次寻址，效率较低。

* **表驱动对象模型**

  ​		表格驱动对象模型对类中的数据成员和函数进行了区分，每个对象保留两个指针，一个指向数据成员表，其中存放数据成员的取值，一个指向成员函数表，其中存放指向成员函数的指针。这种做法的好处是对数据和函数进行分开管理，不好的地方在于访问成员函数是，需要先找到成员函数表，效率更低。

* C++对象模型

  ​		C++ 虚函数。

  ​		C++的多态是通过虚函数实现的。在基类中用virtual关键字定义虚函数，在派生类中重写虚函数，那么在运行时，传入基类指针时候，会根据对象的实际类型来调用正确的函数，实现多态。

  ​		C++类的实例化为不同的对象，这些对象的静态数据成员是共享的，非静态数据成员互不影响，成员函数对各个对象来说是相同的。那么非静态数据成员应该放在每个对象的内存空间中，以保证不同对象相互独立；静态数据成员和成员函数应该放在这个类的公共空间，不用每个对象都存一份，减少存储空间；而虚函数在继承中发挥独特作用，应该与其他成员函数分开。

![C++对象模型](F:\C++对象模型.jpg)

1. C++对象模型中有一个指向虚函数表的指针，这个虚函数表中除了存放虚函数的指针之外，还有一个type_info的信息，用于在运行时识别对象的正确类型。
2. C++对象的非静态成员变量存放在对象的内存空间中，静态成员变量存放在全局数据区。
3. C++对象的成员函数存放在代码区





## 普通继承场景下的对象模型

### 单一继承场景

以Base为基类，定义派生类Derived如下：

```c++
class Derived : public Base
{
public:
    int member;
    static int smember_d;
    
    void func();
    static void sfunc_d();
    virtual void vfunc();
    virutal void vfunc_d();
}
```



此时Derived的对象模型如下：

![对象模型](F:\对象模型.jpg)

派生类有自己的虚函数表，从基类那边拷贝一份，然后进行修改：将type_info改为派生类的信息；

如果派生类重写了基类的虚函数表vfunc，那么虚函数表中用Derived::vfunc()的指针替换Base::vfunc()的指针；

如果派生类新增了虚函数vfunc_d,那么虚函数表中新增一个函数指针指向Derived::vfunc_d()



### 多重继承场景

。。。



